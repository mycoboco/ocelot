/*!
 *  @file    table.h
 *  @brief    Documentation for Table Library (CDSL)
 */

/*!
 *  @mainpage    C Data Structure Library: Table Library
 *  @version     0.2.1
 *  @author      Jun Woong (woong.jun at gmail.com)
 *  @date        last modified on 2010-01-21
 *
 *
 *  @section sec_intro Introduction
 *
 *  This document specifies the Table Library which belongs to the C Data Structure Library. The
 *  basic structure is from David Hanson's book, "C Interfaces and Implementations." I modifies the
 *  original implementation to make it more appropriate for my other projects and to enhance its
 *  readibility; for example a prefix is used more strictly in order to avoid the user namespace
 *  pollution.
 *
 *  Since the book explains its design and implementation in a very comprehensive way, not to
 *  mention the copyright issues, it is nothing but waste to repeat it here, so I finish this
 *  document by giving introduction to the library; how to use the facilities is deeply explained in
 *  files that define them.
 *
 *  The Table Library reserves identifiers starting with @c table_ and @c TABLE_, and imports the
 *  Assertion Library (which requires the Exception Handling Library) and the Memory Management
 *  Library.
 *
 *
 *  @section sec_usage How to Use The Library
 *
 *  The Table Library implements tables that are similar to arrays except that nothing is imposed on
 *  the type of an index to a specific node; it is also known as a "dictionary", "associative array"
 *  or "map" in some languages. A table stores a key and its associated value, and its user is free
 *  to put a new key-value pair, to retrieve a value giving its key, to replace a value for a key
 *  with a new one, and to get rid of a key-value pair from a table. The storage used to maintain a
 *  table itself is managed by the library, but any storage allocated for data stored in tables
 *  should be managed by a user program.
 *
 *  Similarly for other data structure libraries, use of the Table Library follows this sequence:
 *  create, use and destroy. Except for functions to inspect tables, all other functions do one of
 *  them in various ways.
 *
 *  table_new() that creates an empty table takes three unusual arguments. The first one is a hint
 *  for the expected length of the table it creates, and the other two are to specify user-defined
 *  functions that perform creation and comparison of hash values used to represent keys. Some
 *  important conditions that those functions have to satisfy are described in the function.
 *
 *
 *  @section sec_boilerplate Boilerplate Code
 *
 *  Using a table starts with creating one using table_new(). As explained in table_new(), it is
 *  important to provide three arguments properly. If keys to a table are generated by the Hash
 *  Library, the second and third arguments can be granted null pointers, which lets internal
 *  default functions used for the table. table_new() allocates a storage necessary for a table and
 *  if no allocation is possible, an exception is raised instead of returning a failure indicator
 *  like a null pointer.
 *
 *  Once a table created, a key-value pair can be added to and removed from a table using
 *  table_put() and table_remove(). Adding a pair to a table also entails memory allocation, and
 *  thus an exception can be raised. table_get() takes a key and returns its relevant value if any,
 *  and table_length() gives the number of key-value pairs in a table, a.k.a. the length of a table.
 *
 *  There are two ways to apply some operations on every pair in a table; table_map() takes a
 *  user-defined function and calls it for each of key-value pairs, and table_toarray() converts a
 *  table into a dynamic arrays; the array converted from a table has keys in elements with even
 *  indices and values in those with odd ones. A storage for the generated array is allocated by the
 *  library (thus, an exception is possible again), but a user program is responsible for releasing
 *  the storage when the array is no longer necessary.
 *
 *  table_free() takes a table and releases the storage used to maintain it. Note that any storage
 *  allocated by a user program to contain or represent keys and values is not deallocated by the
 *  library.
 *
 *  As an example, the following code creates a table (whose expected length is set to 20 and keys
 *  are generated by the Hash Library), and uses it to compute the frequencies of different
 *  characters in the input. To explain details, it first inspects if the table already has an input
 *  character and its frequency in it. If found, the frequency is simply increased. Otherwise, a
 *  storage to contain the frequency is allocated and put into the table after set properly.
 *
 *  (This is intended to just show an example for using a table; as you (and probably everyone who
 *  have learned to program in C) already know, an ordinary array is enough to print the frequencies
 *  of different characters that appear in the user input.)
 *
 *  @code
 *      int c;
 *      char b;
 *      int *pfrq;
 *      table_t *mytab;
 *      const char *key;
 *      void **pa, **pb;
 *
 *      mytab = table_new(20, NULL, NULL);
 *
 *      while ((c = getchar()) != EOF) {
 *          b = c;
 *          key = hash_new(&b, 1);
 *          if ((pfrq = table_get(mytab, key))) == NULL) {
 *              MEM_NEW(pfrq);
 *              *pfrq = 0;
 *          }
 *          (*pfrq)++;
 *          table_put(mytab, key, pfrq);
 *      }
 *
 *      pa = table_toarray(mytab, NULL);
 *      for (pb = pa; *pb; pb += 2) {
 *          printf("%c: %d\n", *(char *)pb[0], *(int *)pb[1]);
 *          MEM_FREE(pb[1]);
 *      }
 *      MEM_FREE(pa);
 *
 *      hash_reset();
 *      table_free(&mytab);
 *  @endcode
 *
 *  where hash_new() and hash_reset() come from the Hash Library, and MEM_NEW() and MEM_FREE() from
 *  the Memory Management Library.
 *
 *  Things to note include:
 *  - storages for keys and values to be stored into a table should be prepared by a user program,
 *    not the library, thus releasing them properly is up to the user program (MEM_FREE() in the for
 *    loop above and hash_reset() release them);
 *  - since a table has pointers to objects for the frequencies, not their values, increasing values
 *    in the objects effectively updates the table; and
 *  - an array generated by table_toarray() has to be deallocated by a user code.
 *
 *
 *  @section sec_future Future Directions
 *
 *  @subsection subsec_order Retaining Sequence
 *
 *  The Table Library offers two functions that scan every key-value pair maintained in tables.
 *  These functions visit key-value pairs in order that is dependent on the internal structure of
 *  the table, which might force a user to sort them properly if certain sequence is desired. It
 *  would be thus helpful to have those functions to retain sequence in which key-value pairs are
 *  stored into tables.
 *
 *
 *  @section sec_contact Contact Me
 *
 *  Visit http://project.woong.org to get the lastest version of this library. Only a small portion
 *  of my homepage (http://www.woong.org) is maintained in English, thus one who is not good at
 *  Korean would have difficulty when navigating most of other pages served in Korean. If you think
 *  the information you are looking for is on pages written in Korean you cannot read, do not
 *  hesitate to send me an email asking for help.
 *
 *  Any comments about the library are welcomed. If you have a proposal or question on the library
 *  just email me, and then I will reply as soon as possible.
 *
 *
 *  @section sec_license Copyright
 *
 *  I do not wholly hold the copyright of this library; it is mostly held by David Hanson as stated
 *  in his book, "C: Interfaces and Implementations:"
 *
 *  Copyright (c) 1994,1995,1996,1997 by David R. Hanson.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 *  and associated documentation files (the "Software"), to deal in the Software without
 *  restriction, including without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all copies
 *  or substantial portions of the Software.
 *
 *  For the parts I added or modified, the following applies:
 *
 *  Copyright (C) 2009 by Jun Woong.
 *
 *  This package is a table implementation by Jun Woong. The implementation was written so as to
 *  conform with the Standard C published by ISO 9899:1990 and ISO 9899:1999.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 *  and associated documentation files (the "Software"), to deal in the Software without
 *  restriction, including without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all copies
 *  or substantial portions of the Software.
 *
 *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
